const { test, expect } = require('@playwright/test');

/**
 * Test suite: Security Penetration Testing
 * Tests security headers, XSS, CSRF, and other security vulnerabilities
 */

test.describe('Security - HTTP Headers', () => {
  test('should have X-Content-Type-Options header', async ({ page }) => {
    const response = await page.goto('/');
    const headers = response.headers();

    expect(headers['x-content-type-options']).toBe('nosniff');
  });

  test('should have X-Frame-Options header', async ({ page }) => {
    const response = await page.goto('/');
    const headers = response.headers();

    expect(headers['x-frame-options']).toBe('DENY');
  });

  test('should have X-XSS-Protection header', async ({ page }) => {
    const response = await page.goto('/');
    const headers = response.headers();

    expect(headers['x-xss-protection']).toMatch(/1; mode=block/);
  });

  test('should have Referrer-Policy header', async ({ page }) => {
    const response = await page.goto('/');
    const headers = response.headers();

    expect(headers['referrer-policy']).toBeTruthy();
    expect(headers['referrer-policy']).toMatch(/no-referrer-when-downgrade|strict-origin-when-cross-origin|no-referrer/);
  });

  test('should not expose server version', async ({ page }) => {
    const response = await page.goto('/');
    const headers = response.headers();

    if (headers['server']) {
      // Server header should not contain version numbers
      expect(headers['server']).not.toMatch(/\d+\.\d+/);
    }
  });

  test('should have Content-Security-Policy (recommended)', async ({ page }) => {
    const response = await page.goto('/');
    const headers = response.headers();

    // CSP is highly recommended but not required for this test
    if (headers['content-security-policy']) {
      expect(headers['content-security-policy']).toBeTruthy();
    }
  });

  test('should have Strict-Transport-Security for HTTPS', async ({ page }) => {
    const response = await page.goto('/');
    const url = response.url();

    if (url.startsWith('https://')) {
      const headers = response.headers();
      expect(headers['strict-transport-security']).toBeTruthy();
    }
  });
});

test.describe('Security - XSS Protection', () => {
  test('should sanitize user input if any exists', async ({ page }) => {
    await page.goto('/');
    await page.waitForLoadState('networkidle');

    // Try to inject XSS through any input fields
    const inputs = await page.locator('input, textarea').all();

    for (const input of inputs) {
      await input.fill('<script>alert("XSS")</script>');
      await page.waitForTimeout(100);

      // Check if script was executed (should not be)
      const alerts = [];
      page.on('dialog', dialog => {
        alerts.push(dialog.message());
        dialog.dismiss();
      });

      await page.waitForTimeout(500);
      expect(alerts).toHaveLength(0);
    }
  });

  test('should not execute inline scripts from DOM manipulation', async ({ page }) => {
    await page.goto('/');
    await page.waitForLoadState('networkidle');

    const xssAttempted = await page.evaluate(() => {
      try {
        const div = document.createElement('div');
        div.innerHTML = '<img src=x onerror="window.xssExecuted=true">';
        document.body.appendChild(div);
        return window.xssExecuted === true;
      } catch (e) {
        return false;
      }
    });

    expect(xssAttempted).toBe(false);
  });

  test('should properly encode special characters', async ({ page }) => {
    await page.goto('/');
    await page.waitForLoadState('networkidle');

    // Check if HTML special characters are properly handled
    const hasProperEncoding = await page.evaluate(() => {
      const testStrings = ['<script>', '&', '"', "'", '/'];
      const div = document.createElement('div');

      for (const str of testStrings) {
        div.textContent = str;
        const html = div.innerHTML;
        // Properly encoded or kept as text
        if (html.includes(str) || html.includes('&lt;') || html.includes('&gt;')) {
          continue;
        } else {
          return false;
        }
      }
      return true;
    });

    expect(hasProperEncoding).toBe(true);
  });
});

test.describe('Security - Information Disclosure', () => {
  test('should not expose sensitive information in HTML comments', async ({ page }) => {
    await page.goto('/');
    const content = await page.content();

    // Check for common sensitive info patterns in comments
    const sensitivePatterns = [
      /<!--.*password.*-->/gi,
      /<!--.*secret.*-->/gi,
      /<!--.*api[_-]?key.*-->/gi,
      /<!--.*token.*-->/gi,
      /<!--.*credential.*-->/gi,
    ];

    for (const pattern of sensitivePatterns) {
      expect(content).not.toMatch(pattern);
    }
  });

  test('should not expose environment variables', async ({ page }) => {
    await page.goto('/');
    const content = await page.content();

    // Common environment variable patterns
    const envPatterns = [
      /AWS_SECRET/gi,
      /DATABASE_URL/gi,
      /PRIVATE_KEY/gi,
      /ACCESS_TOKEN/gi,
    ];

    for (const pattern of envPatterns) {
      expect(content).not.toMatch(pattern);
    }
  });

  test('should not expose stack traces', async ({ page }) => {
    const errors = [];
    page.on('console', msg => {
      if (msg.type() === 'error') {
        errors.push(msg.text());
      }
    });

    await page.goto('/');
    await page.waitForLoadState('networkidle');

    // Trigger various interactions that might expose errors
    await page.keyboard.press('ArrowUp');
    await page.keyboard.press('ArrowDown');
    await page.keyboard.press('ArrowLeft');
    await page.keyboard.press('ArrowRight');

    // Check if any stack traces are exposed
    for (const error of errors) {
      expect(error).not.toMatch(/at.*\(.*:\d+:\d+\)/); // Stack trace pattern
    }
  });
});

test.describe('Security - Clickjacking Protection', () => {
  test('should prevent iframe embedding', async ({ page, context }) => {
    const response = await page.goto('/');
    const headers = response.headers();

    // Either X-Frame-Options or CSP frame-ancestors should be set
    const hasClickjackingProtection =
      headers['x-frame-options'] === 'DENY' ||
      headers['x-frame-options'] === 'SAMEORIGIN' ||
      (headers['content-security-policy'] &&
       headers['content-security-policy'].includes('frame-ancestors'));

    expect(hasClickjackingProtection).toBe(true);
  });
});

test.describe('Security - MIME Sniffing Protection', () => {
  test('should prevent MIME type sniffing', async ({ page }) => {
    const response = await page.goto('/');
    const headers = response.headers();

    expect(headers['x-content-type-options']).toBe('nosniff');
  });

  test('should have correct Content-Type header', async ({ page }) => {
    const response = await page.goto('/');
    const headers = response.headers();

    expect(headers['content-type']).toMatch(/text\/html/);
  });
});

test.describe('Security - Cookie Security (if applicable)', () => {
  test('cookies should have Secure flag for HTTPS', async ({ page }) => {
    await page.goto('/');
    const url = page.url();

    if (url.startsWith('https://')) {
      const cookies = await page.context().cookies();

      for (const cookie of cookies) {
        if (!cookie.name.startsWith('__')) { // Ignore browser internal cookies
          expect(cookie.secure).toBe(true);
        }
      }
    }
  });

  test('cookies should have HttpOnly flag where appropriate', async ({ page }) => {
    await page.goto('/');
    const cookies = await page.context().cookies();

    // Session/auth cookies should be HttpOnly
    const authCookies = cookies.filter(c =>
      c.name.toLowerCase().includes('session') ||
      c.name.toLowerCase().includes('auth') ||
      c.name.toLowerCase().includes('token')
    );

    for (const cookie of authCookies) {
      expect(cookie.httpOnly).toBe(true);
    }
  });

  test('cookies should have SameSite attribute', async ({ page }) => {
    await page.goto('/');
    const cookies = await page.context().cookies();

    for (const cookie of cookies) {
      if (!cookie.name.startsWith('__')) {
        expect(cookie.sameSite).toBeTruthy();
        expect(['Strict', 'Lax', 'None']).toContain(cookie.sameSite);
      }
    }
  });
});

test.describe('Security - Resource Loading', () => {
  test('should load resources over HTTPS in production', async ({ page }) => {
    const response = await page.goto('/');
    const url = response.url();

    if (url.startsWith('https://')) {
      const resources = [];
      page.on('request', request => {
        resources.push(request.url());
      });

      await page.waitForLoadState('networkidle');

      // All resources should be HTTPS or data URIs
      for (const resource of resources) {
        expect(
          resource.startsWith('https://') ||
          resource.startsWith('data:') ||
          resource.startsWith('blob:')
        ).toBe(true);
      }
    }
  });

  test('should not load resources from untrusted domains', async ({ page }) => {
    const suspiciousRequests = [];

    page.on('request', request => {
      const url = request.url();
      const suspiciousDomains = [
        'doubleclick.net',
        'malware.com',
        'phishing.com',
        'tracker.com',
      ];

      for (const domain of suspiciousDomains) {
        if (url.includes(domain)) {
          suspiciousRequests.push(url);
        }
      }
    });

    await page.goto('/');
    await page.waitForLoadState('networkidle');

    expect(suspiciousRequests).toHaveLength(0);
  });
});

test.describe('Security - Client-Side Storage', () => {
  test('should not store sensitive data in localStorage', async ({ page }) => {
    await page.goto('/');
    await page.waitForLoadState('networkidle');

    const localStorageData = await page.evaluate(() => {
      const data = {};
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        data[key] = localStorage.getItem(key);
      }
      return JSON.stringify(data);
    });

    // Check for sensitive patterns
    const sensitivePatterns = [
      /password/gi,
      /secret/gi,
      /api[_-]?key/gi,
      /private[_-]?key/gi,
      /access[_-]?token/gi,
    ];

    for (const pattern of sensitivePatterns) {
      expect(localStorageData).not.toMatch(pattern);
    }
  });

  test('should not store sensitive data in sessionStorage', async ({ page }) => {
    await page.goto('/');
    await page.waitForLoadState('networkidle');

    const sessionStorageData = await page.evaluate(() => {
      const data = {};
      for (let i = 0; i < sessionStorage.length; i++) {
        const key = sessionStorage.key(i);
        data[key] = sessionStorage.getItem(key);
      }
      return JSON.stringify(data);
    });

    const sensitivePatterns = [
      /password/gi,
      /secret/gi,
      /api[_-]?key/gi,
      /private[_-]?key/gi,
    ];

    for (const pattern of sensitivePatterns) {
      expect(sessionStorageData).not.toMatch(pattern);
    }
  });
});

test.describe('Security - Input Validation', () => {
  test('should handle extremely long input gracefully', async ({ page }) => {
    await page.goto('/');
    await page.waitForLoadState('networkidle');

    const inputs = await page.locator('input, textarea').all();

    for (const input of inputs) {
      const longString = 'A'.repeat(10000);
      await input.fill(longString);
      await page.waitForTimeout(100);

      // Page should still be responsive
      const isVisible = await page.locator('body').isVisible();
      expect(isVisible).toBe(true);
    }
  });

  test('should handle special characters in input', async ({ page }) => {
    await page.goto('/');
    await page.waitForLoadState('networkidle');

    const inputs = await page.locator('input, textarea').all();
    const specialChars = ['<>', '&', '"', "'", '/', '\\', '\0', '%00'];

    for (const input of inputs) {
      for (const char of specialChars) {
        await input.fill(char);
        await page.waitForTimeout(50);

        // Page should still be functional
        const isVisible = await page.locator('body').isVisible();
        expect(isVisible).toBe(true);
      }
    }
  });
});

test.describe('Security - Error Handling', () => {
  test('should handle network errors gracefully', async ({ page }) => {
    // Navigate to a non-existent resource
    const response = await page.goto('/nonexistent-page.html').catch(() => null);

    if (response && response.status() === 404) {
      // Should show generic error, not expose internal details
      const content = await page.content();
      expect(content).not.toMatch(/stack trace/gi);
      expect(content).not.toMatch(/internal server error/gi);
    }
  });

  test('should not expose detailed error messages', async ({ page }) => {
    const consoleMessages = [];
    page.on('console', msg => {
      if (msg.type() === 'error') {
        consoleMessages.push(msg.text());
      }
    });

    await page.goto('/');
    await page.waitForLoadState('networkidle');

    // Trigger various actions
    await page.keyboard.press('ArrowUp');
    await page.keyboard.press('ArrowDown');

    // Error messages should not contain file paths or internal details
    for (const msg of consoleMessages) {
      expect(msg).not.toMatch(/\/home\//);
      expect(msg).not.toMatch(/\/var\//);
      expect(msg).not.toMatch(/C:\\/);
    }
  });
});
